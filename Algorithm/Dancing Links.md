> [[算法]Dancing Links (DLX) I](http://blog.csdn.net/keyboardlabourer/article/details/13015689)

# 1.概述

Dacing Links (DLX) 算法是Donald Knuth 提出，用以解决精确覆盖（exact cover）问题，是X算法在计算机上的优化。

## 1.1 精确覆盖问题

所谓精确覆盖，是指两两不相交的子集的集合，这些子集的并集可以得到全集。完整的定义 [[1]](http://zh.wikipedia.org/wiki/%E7%B2%BE%E7%A1%AE%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98)如下：

在一个全集X中若干子集的集合为S，精确覆盖是指，S的子集S*，满足X中的每一个元素在S*中恰好出现一次。

举例：令 S = {N, O, E, P} 是集合X = {1, 2, 3, 4}的一个子集，并满足：
N = { }
O = {1, 3}
E = {2, 4}
P = {2, 3}.
其中一个子集 {O, E} 是 X的一个精确覆盖,因为 O = {1, 3} 而 E = {2, 4} 的并集恰好是 X = {1, 2, 3, 4}。同理， {N, O, E} 也是 X 的一个精确覆盖。

用关系矩阵来表示S的每个子集与X的元素之间包含关系，矩阵每行表示S的一个子集，每列表示X中的一个元素。矩阵行列交点元素为1表示对应的元素在对应的集合中，不在则为0。

![img](http://img.blog.csdn.net/20131025110323515)

精确覆盖问题转化成了求矩阵的若干个行的集合，使每列有且仅有一个1。S* = {B, D, F} 便是一个精确覆盖。

## 1.2 双向十字链表

实现DLX算法的数据结构是双向十字链表，现在先简单介绍一下双向十字链表。

双向十字链表用LRUD来记录，LR来记录左右方向的双向链表，UD来记录上下方向的双向链表。比如，对6*7矩阵

![img](http://img.blog.csdn.net/20131025110331234)

用双向十字链表可以表示如下：

![img](http://img.blog.csdn.net/20131025124523640)

其中，h代表总的头链表head，ABCDEFG为列的指针头。

双向十字链表可以用数组来加以模拟。对4*4的01矩阵（[4]中的一个例子）

1 1  0 0

0 0  0 1

0 1  1 1

1 0  1 0

LRUD的双向十字链表结构如下：

![img](http://my.csdn.net/uploads/201206/03/1338696511_4823.gif)

其中，把头节点head编号为0，列分别编号为1,2,3,4。第一行的两个1编号为5,6，第二行的一个1编号为7，第三行三个1编号为8,9,10。第四行两个1，编号为11,12。编号的顺序都是从左到右。1列的下一个节点就是编号为5的1，编号为5的1的下面又是编号11的1，编号为5的1的左边和右边都是编号为6的1。

## 1.3 DLX算法描述

对精确覆盖问题，容易想到一个启发式的递归算法：

- （1）选中关系矩阵A的列c，则满足A(i, c)=1的行i均不可用，删除列c与所有的行i；


- （2）对选中的列c，选中行r满足A(r, c)=1；则满足A(r, j)=1的列j也均不可用，删除行与所有的列j；

> 满足A(r,j)=1的列j也不可用，防止以后还会在列j上有1出现
>
> 这样子，列j上有1出现的行也要删除，这就是为什么后面的```从矩阵A中删除第i行。```

- （3）对删除后的A进行递归（1）（2）处理。

上述非确定算法即是X算法，伪代码如下：

```pseudocode
如果A是空的，问题解决；成功终止。
否则，选择一个列c（确定的）。
选择一个行r，满足 A[r, c]=1 （不确定的）。
把r包含进部分解。
对于所有满足 A[r,j]=1 的列j，
　　从矩阵A中删除第j列；
　　对于所有满足 A[i,j]=1 的i，
　　　　从矩阵A中删除第i行。
```

在不断减少的矩阵A上递归地重复上述算法。

对X算法的优化一：在X算法的步骤（2）中选择的行r有可能是错的，为了减少递归次数，则需要回溯。为了便于X算法中有查找、删除等操作以及回溯，可采用双向十字链表。假设x 指向双向链的一个节点；L[x] 和R[x] 分别表示x 的前驱节点和后继节点。每个程序员都知道如下操作：
```
(1) L[R[x]] ← L[x], R[L[x]] ← R[x] 
```

将x 从链表删除的操作。但是只有少数程序员意识到如下操作：
```pseudocode
(2) L[R[x]] ← x, R[L[x]] ← x
```
是把x重新链接到双向链中。关于操作(2)的研究促使Knuth写了论文[[(Donald Knuth, Dancing Links.)2]](https://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/0011047.pdf)(Inaccessible?)，操作(2)为了回溯用的，也正是DLX算法的精髓。

对DLX算法的优化二：在选择列c时，应选择的是A中所有列中元素最少的一列。至于为什么选择最少的一列，不在本文讨论之列。如果去掉优化二，写的代码很有可能TLE。

为建立关系矩阵A的双向十字链表、加快运行速度。对每一个对象，记录如下几个信息：

- L[x], R[x], U[x], D[x], C[x]；LR来记录左右方向的双向链表，UD来记录上下方向的双向链表；C[x]是指向其列指针头的地址，即表示x所在的列。
- head指向总的头指针，head通过LR来贯穿的列指针头。
- 每一列都有列指针头。行指针头可有可无，为了更方便地建立左右方向的双向链表，加个行指针头还是很有必要的。
- 另外，开两个数组S[x], O[x]；S[x]记录列链表中结点的总数，O[x]用来记录搜索结果。

DLX算法的伪代码如下：

```pseudocode
如果 R[h]=h ，打印当前的解（见下）并且返回。
否则选择一个列对象c（见下）。
覆盖列c（见下）。
对于每个r←D[c]，D[D[c]]，……，当 r!=c，
	设置 ans[k]←r；
	对于每个j←R[r]，R[R[r]]，……，当 j!=r，
		覆盖列j（见下）；
	search(k+1)；
	设置 r←ans[k] 且 c←C[r]；
	对于每个j←L[r]，L[L[r]]，……，当 j!=r，
		取消列j的覆盖（见下）。
取消列c的覆盖（见下）并且返回。
```

![img](http://img.blog.csdn.net/20131025123101968)

其中，R[h]=h即表示A为空，cover column操作即为X算法中步骤（1），uncover colunm操作即为回溯（步骤（2））。关于DLX算法的演示过程请参看[[6]](http://blog.csdn.net/mu399/article/details/7627763)。

代码

[Code](Dancing_Link.cc)





