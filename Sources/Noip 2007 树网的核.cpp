/*
在数网中，最长的路径是直径，直径可以有很多条（可以有多条长度相同的），而偏心距指的是在数网中，距离树网的核最远的点到路径的距离，这里我们会想到用最短路径，本题任务是在某条直径中截一段不超过s的路径，使这条路径的偏心距最小

算法原理：

   通过Floyd算法，对数网中任意两点间距离进行更新至最短路径，然后通过枚举，找出这个数网中的直径（即最长的），并记录直径长度，然后继续通过枚举每一个节点，判断它是否为直径（即长度是否符合，if d[i,j]=max），在直径的基础上，继续枚举每一个节点，判断其是否是这条直径上的点(if d[i,k]+d[k,j]=max)，如果是，就进行标记(q[k]=true)；

   枚举所有点（双重循环，因为需要起终点），如果两个点都在直径上（符合第一个要求）并且长度不超过s（符合第二个要求）(if (q[i])&&(q[j])&&(d[i,j]<=s)，
   然后枚举所有的点，判断它是否在这条路径上（d[i,k]+d[k,j]=d[i,j]），对于在这条路径上的点，枚举它到每一个节点的距离，与
   min[k]相比，如果更小，就进行更新，最后找出这条路径的偏心距；往复循环，直到所有符合要求的路径的偏心距都已找出，就进行比较，
   找出其中最小的，就是答案。*/
