/*
sources:http://blog.csdn.net/u013174702/article/details/45620723
这一题实际上是组合数学里面的经典问题，跟第二类Stirling数有些相似。可以把一个数值为n的数看成n个小球，

划分的份数k看作是k个盒子，那么本题的要求就是：

将n个小球放到k个盒子中，小球之间与盒子之间没有区别，并且最后的结果不允许空盒

与第二类Stirling数的递推公式的推导过程相似：

将n个小球放到k个盒子中的情况总数 =

1. 至少有一个盒子只有一个小球的情况数

+

2. 没有一个盒子只有一个小球的情况数



这样进行划分的原因是这种分类足够特殊，1和2都有可以写出来的表达式：

1. 因为盒子不加区分，那么1的情况数与“将n-1个小球放到k-1个盒子中”的情况数一样

2. 没有一个盒子只有一个小球，那么把每个盒子中拿出来一个小球，对应的是“把(n-k)个小球放到k个盒子中的情况数”

至于1和2中的两种等价关系为什么成立，可以用集合A=集合B的方式去证明



最后将上面的叙述转化为dp的表达形式：

f[n][k]代表将n个小球放到k个盒子中且没有空盒的情况，那么

f[n][k] = f[n-1][k-1] + f[n-k][k]
转化成代码即可
*/


#include <stdio.h>
int f[205][10];
int main() {
	int n, k, i, j;
	scanf("%d%d", &n, &k);
	for (i = 1; i <= n; i++) {
		f[i][1] = 1;
	}
	
	f[0][0] = 1;
	for (i = 1; i <= n; i++) {
		for (j = 1; j <= k && j <= i; j++) {
			f[i][j] = f[i - 1][j - 1] + f[i - j][j];
		}
	}
	printf("%d\n", f[n][k]);
	return 0;
}
