/*用线段树 f 维护，每个点 i 向左、向右最长连续空闲区域能延伸到哪里：l[i]、r[i]，//i所在得区间有的最大空闲长度

同时记 g[i] 为以 i 开始的最长空闲区域长度，即用线段树维护区间 g 的最大值，//当i-1==1&&i==0,g[i]=r[i]-i+1

malloc(K)：
找出最早出现的能容纳 K 个的区域。这时在线段树 g 中跑一下，如果左子树最大值 >=K 就往左子树走，否则往右子树走，这样就能找到最早出现的位置 i 了
然后就是在线段树 f 中将 i+K ~ r[i] 这段的 l 全部改成 i+K，//将 i ~ i+K-1 这段全部抹掉
同时将线段树 g 中的 g[i] 删除,g[i]=0, //g[i~i+k]=0 //i+k==1，不能算空闲

free(i,K)：
//插入 i ~ i+K-1 后，左边空闲区域和右边空闲区域会合并，因此找出最左端 l 和最右端 r
//在线段树 f 中将 l ~ r 这段 l 全部改成 l ，r 全部改成 r
//在线段树 g 中将 g[ l ] 更新，删除 g   //g[l]
max_l = {l[i-1] (if(i-1!=1)),i(if(i-1==1))}，//画图
max_r 同理
更新g[i]

print：
map<string,int>
*/
